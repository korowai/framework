<?php
/**
 * This file is part of the Korowai package
 *
 * @author PaweÅ‚ Tomulik <ptomulik@meil.pw.edu.pl>
 * @package Korowai\Ldif
 * @license Distributed under MIT license.
 */

declare(strict_types=1);

namespace Korowai\Component\Ldif\Preprocessor;

/**
 * Functions that support LDIF text preprocessing.
 */
trait PpFunctions
{
    /**
     * Generates and returns "jump array". The "jump array" is generated by
     * preprocessor when removing parts of LDIF code such as line continuations
     * or comments. Jump array is used later to map character offset in the
     * preprocessed LDIF string onto character offsets in the original LDIF
     * string.
     *
     * @param array $pieces pieces of the original string as produced by
     *                      preg_split(..., PREG_SPLIT_OFFSET_CAPTURE)
     * @return array
     */
    protected static function ppMkJumps(array $pieces) : array
    {
        $jumps = [];
        $offset = 0;
        foreach($pieces as $piece) {
            $jumps[] = [$offset, $piece[1]];
            $offset += strlen($piece[0]);
        }
        return $jumps;
    }

    /**
     * Applies one "jump array" ($new) over another one ($old). Used by LDIF
     * preprocessor to implement sequential substring removals.
     *
     * @param array $old original jump array from previous string removals
     * @param array $new a new jump array to be applied to $old
     *
     * @return array
     */
    protected static function ppApplyJumps(array $old, array $new) : array
    {
        $jumps = [];
        $ns = 0; // new shrink (introduced by $new)
        $ts = 0; // total shrink (cumulation of $old and $new)
        for($i=0, $j=0; $i < count($old) || $j < count($new); ) {
            if( $j < count($new) &&
               ($i >= count($old) || $new[$j][1] < ($old[$i][0] - $ns))) {
                //
                // $new[$j] on the left side of $old[$i]
                //
                $ts += ($new[$j][1] - $new[$j][0]);
                $jumps[] = [$new[$j][0], $new[$j][0] + $ts];
                $ns += ($new[$j][1] - $new[$j][0]);
                $j++;
            } elseif($j < count($new) && $i < count($old) &&
                     $new[$j][0] <= $old[$i][0] - $ns) {
                //
                // $new[$j] encloses $old[$i] (and perhaps $old[$i+1], ...)
                //
                $ts += ($new[$j][1] - $new[$j][0]);
                do {
                    $ts += ($old[$i][1] - $old[$i][0]);
                    $i++;
                } while($i < count($old) && $new[$j][1] >= $old[$i][0] - $ns);
                $jumps[] = [$new[$j][0], $new[$j][0] + $ts];
                $ns += ($new[$j][1] - $new[$j][0]);
                $j++;
            } elseif($i < count($old)) {
                //
                // $new[$j] on the right side of $old[$i]
                //
                $jumps[] = [$old[$i][0] - $ns, $old[$i][1]];
                $ts += ($old[$i][1] - $old[$i][0]);
                $i++;
            } else {
                throw \RuntimeException("internal error");
            }
        }
        return $jumps;
    }

    /**
     * Assembles pieces produced by ppRmRe() and updates "jump array".
     *
     * @param array $pieces
     * @param array $jumps
     */
    protected static function ppAsmPieces(array $pieces, array &$jumps=null) : string
    {
        if($jumps === null) {
            $jumps = self::ppMkJumps($pieces);
        } else {
            $jumps = self::ppApplyJumps($jumps, self::ppMkJumps($pieces));
        }
        return implode(array_map(function ($p){return $p[0];}, $pieces));
    }

    /**
     * Removes parts of the string that match a regular expression $re.
     *
     * @param string $re the regular expression to be matched
     * @param string $src the original string
     * @param array $jumps a reference to "array of jumps"
     *
     * @return string new string with removed parts that matched $re.
     */
    protected static function ppRmRe(string $re, string $src, array &$jumps=null) : string
    {
        $flags = PREG_SPLIT_OFFSET_CAPTURE | PREG_SPLIT_NO_EMPTY;
        $pieces = preg_split($re, $src, -1, $flags);
        return self::ppAsmPieces($pieces, $jumps);
    }

    /**
     * Removes line continuations from LDIF text (unfolds the lines).
     *
     * @param string $src
     * @param array $jumps
     * @return string
     */
    protected static function ppRmLnCont(string $src, array &$jumps=null) : string
    {
        return self::ppRmRe('/(?:\r\n|\n) /mu', $src, $jumps);
    }

    /**
     * Removes comment lines from LDIF text.
     *
     * @param string $src
     * @param array $jumps
     * @return string
     */
    protected static function ppRmComments(string $src, array &$jumps=null) : string
    {
        return self::ppRmRe('/^#(?:[^\r\n])*(?:\r\n|\n)?/mu', $src, $jumps);
    }
}

// vim: syntax=php sw=4 ts=4 et:
